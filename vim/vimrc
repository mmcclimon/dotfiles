" vim:fdm=marker
" vim:set filetype=vim

" General -----------------------------------------------------{{{
set nocompatible
" }}}
" Vundle ------------------------------------------------------{{{
filetype off                        " required!

set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

" Vundle must manage itself!
Bundle 'gmarik/vundle'

Bundle 'scrooloose/nerdtree'
Bundle 'kien/ctrlp.vim'
Bundle 'majutsushi/tagbar'
Bundle 'Lokaltog/vim-easymotion'
Bundle 'pangloss/vim-javascript'
Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-fugitive'
Bundle 'derekwyatt/vim-scala'
Bundle 'vim-pandoc/vim-pandoc'
Bundle 'tpope/vim-markdown'
Bundle 'guns/vim-clojure-static'
Bundle 'kien/rainbow_parentheses.vim'
Bundle 'bufkill.vim'

filetype plugin indent on           " required!

" }}}
" Text Editing ------------------------------------------------{{{
set backspace=indent,eol,start
set autoindent
set smartindent
set tabstop=4
set shiftwidth=4
set expandtab

" }}}
" Abbrevs -----------------------------------------------------{{{
iabbrev teh the
iabbrev functino function
iabbrev Micahel Michael
iabbrev becuase because
iabbrev taht that
iabbrev wiht with
iabbrev acutal actual
iabbrev si is
" }}}
" Backups -----------------------------------------------------{{{
set backup        " keep a backup file
set backupdir=~/.vim/backup
set autowrite
" }}}
" UI ----------------------------------------------------------{{{
set history=50      " keep 50 lines of command line history
set ruler           " show the cursor position all the time
set showcmd         " display incomplete commands
set incsearch       " do incremental searching
set ignorecase
set smartcase
set hidden
set laststatus=2
set number
set hidden
set wildmenu
set wildmode=list:longest
set list
set listchars=tab:▸\ ,trail:·,extends:❯,precedes:❮

if has('mouse')
  set mouse=a
endif

if &t_Co > 2 || has("gui_running")
  syntax on
  set hlsearch
endif

function! SyntaxItem()
    return synIDattr(synID(line("."),col("."),1),"name")
endfunction

set statusline=%<%f\ %h%m%r\ %{SyntaxItem()}%=%-14.(%l,%c%V%)\ %P
" }}}
" Folding -----------------------------------------------------{{{
set nofoldenable
set foldlevel=10
augroup folding
    au!
    au BufReadPre * setlocal foldmethod=indent
    au BufWinEnter * if &fdm == 'indent' | setlocal foldmethod=manual | endif
augroup END
" }}}
" Global mappings ---------------------------------------------{{{
let mapleader=","
let maplocalleader = '\'
nnoremap <silent> <leader>s :nohls<CR>
nnoremap q: <Nop>
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" swap colon/semicolon
nnoremap ; :
nnoremap : ;

" Uppercase last word in insert mode (stolen from Steve Losh).
" Overwrites z mark
inoremap <C-u> <esc>mzgUiw`za

function! ExecCurrentLine()
    let l:curline = getline('.')
    echo ":" . l:curline
    execute l:curline
    sleep 1
    redraw
endfunction

nnoremap <C-x><C-e> :call ExecCurrentLine()<CR>
inoremap <c-c> <esc>
" }}}
" Plugins -----------------------------------------------------{{{
" NERDTree ----------------------------------------------------{{{
nnoremap <F5> :NERDTreeToggle<CR>
" }}}
" EasyMotion --------------------------------------------------{{{
nnoremap <leader>f :call EasyMotion#F(0, 0)<CR>
" }}}
" }}}

" MiniBufExplorer ---------------------------------------------{{{
if has("gui_running")
    let g:miniBufExplorerMoreThanOne=0
endif

hi link MBEVisibleChangedActive Statement
hi link MBEVisibleNormal Normal
hi link MBEVisibleChanged Underlined
" }}}
" CtrlP -------------------------------------------------------{{{
" use ack to find known files
let g:ctrlp_user_command = 'ack -f'
nnoremap <leader>b :CtrlPBuffer<cr>
" }}}
" vim-pandoc---------------------------------------------------{{{
let g:pandoc_use_hard_wraps = 1
let g:pandoc_auto_format = 1
" }}}
" FixWhitespace------------------------------------------------{{{
function! FixWhitespace()
    let l:save_cursor = getpos(".")
    silent! execute ':%s/\s\+$//'
    call setpos('.', l:save_cursor)
endfunction

augroup trailing
    au!
    au InsertEnter * :set listchars-=trail:·
    au InsertLeave * :set listchars+=trail:·
augroup END

augroup prewrite
    au!
    au BufWritePre * call FixWhitespace()
augroup END
" }}}
" Bufkill -----------------------------------------------------{{{
" Make c-x c-c write and close a buffer (useful for git commit
" edit messages, etc.)
nnoremap <C-x><C-c> :w<bar>BD<cr>

" Tagbar ------------------------------------------------------{{{
let g:tagbar_iconchars = ['▸', '▾']
hi TagbarVisibilityPublic guifg=#04b404
hi TagbarVisibilityProtected guifg=#0489b1
hi TagbarVisibilityPrivate guifg=#b40404
" }}}
" }}}
" Misc. Filetypes ---------------------------------------------{{{
au BufEnter /private/tmp/crontab.* setl backupcopy=yes
" }}}
" Org mode ----------------------------------------------------{{{
augroup org_mode
    au!
    au BufReadPre *.org set filetype=org
    au Filetype org set tabstop=2 shiftwidth=2
    au Filetype org set textwidth=76
augroup END

" Toggle an Org Checkbox
" (uses mark z to save place, and wipes out whatever else is there)
function! OrgCheckboxToggle ()
  execute "normal! mz"
  let line = getline(".")
  if match(line, '- \[ \]') >= 0
    substitute/- \[ \]/- [X]/
  elseif match(line, '- \[[xX]\]') >= 0
    substitute/- \[[xX]\]/- [ ]/
  endif
  execute "normal! g`z"
endfunction

nnoremap <silent> <localleader>cc :call OrgCheckboxToggle()<cr>

hi link org_heading1 Directory
" }}}
" Ruby --------------------------------------------------------{{{
augroup ft_ruby
    au!
    au Filetype ruby set tabstop=2 shiftwidth=2
augroup END
" }}}
" Markdown ----------------------------------------------------{{{
augroup ft_markdown
    au!
    au Filetype markdown set textwidth=78
augroup END
" }}}
" Markdown ----------------------------------------------------{{{
augroup ft_javascript
    au!
    au Filetype javascript set tabstop=2 shiftwidth=2
augroup END
" }}}

" Better search highlighting ----------------------------------{{{
highlight WhiteOnRed guibg=#da4939 guifg=white

function! HLNext (blinktime)
    let [bufnum, lnum, col, off] = getpos('.')
    let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
    let target_pat = '\c\%#'.@/
    let ring = matchadd('WhiteOnRed', target_pat, 101)
    redraw
    exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
    call matchdelete(ring)
    redraw
endfunction

" This rewires n and N to do the highlighing...
nnoremap <silent> n   n:call HLNext(0.4)<cr>
nnoremap <silent> N   N:call HLNext(0.4)<cr>
" }}}


" Scratch buffers ---------------------------------------------{{{
function! CreateOrSwitchToScratchBuffer()
    if buflisted("_scratch") == 0
        badd _scratch
        buffer _scratch
        set buftype=nofile
        set filetype=pandoc
        call append(0, '% This is a scratch buffer, set up with ft=pandoc')
        call append(1, '% You cannot save this file unless you write it somewhere else first')
    else
        buffer _scratch
    endif
endfunction

nnoremap <C-x><C-b> :call CreateOrSwitchToScratchBuffer()<CR>
" }}}
